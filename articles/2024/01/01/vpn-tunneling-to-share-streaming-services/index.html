<html><head></head><body><article class="post-581 post type-post status-publish format-standard hentry category-uncategorized" id="post-581">
<header class="entry-header">
<h1 class="entry-title">Sharing Streaming Services Across Households</h1> </header><!-- .entry-header -->
<div class="entry-content">
<p>Picture this: you settle in to enjoy a streaming session on your smart TV, only to be greeted by an error message instead of the usual lineup of movie titles. This error message states that your account—or rather, a family member’s account that you’ve been using—can no longer be accessed from this household.</p>
<p>While most people would see this as a cue to purchase a personal subscription, I saw it as a golden opportunity to learn more about computer networking. Thus, I set out to work around this restriction and document the process.</p>
<p>Along my journey, I learned a lot about the Linux networking stack and about OpenWrt, a popular Linux distribution for network routers. Someone with substantial networking experience will probably laugh at my ignorance throughout this blog post, but I’m hoping that most readers will be able to learn something just as I did.</p>
<h2 class="wp-block-heading">The Problem</h2>
<p>This scenario is familiar to many people: my parents subscribe to a bunch of streaming services, and I want to access these services without being on their home internet. Unfortunately, some streaming services are starting to wise up, checking that all the devices on an account are actually connected to the same network.</p>
<p>Since I periodically have access to my parents’ house, I’ll assume that I can put a Linux server behind their router and setup port forwarding to access this server remotely. Ideally, I’d like to tunnel internet traffic from my TV through this server, since this would mean all requests to streaming services would appear to originate from their home IP. If I could achieve this, it would effectively solve the problem.</p>
<p>Unfortunately, smart TVs are actually quite <em>dumb</em> most of the time, so I’ll assume that I can’t directly setup a VPN—or any other type of proxy—on the TV itself. The only thing I can configure on the TV is the WiFi network that it is connected to.</p>
<h2 class="wp-block-heading">The Solution</h2>
<p>In short, I bought a cheap <a href="https://www.amazon.com/GL-iNET-GL-MT300N-V2-Repeater-300Mbps-Performance/dp/B073TSK26W/ref=sr_1_8">GL.iNet router</a> and configured it to host a special WiFi network whose traffic is tunneled through my parents’ home network. Consequently, I can connect my TV to this WiFi network in my own apartment, and all of the TV’s internet traffic will appear to originate from my parents’ IP address. This bypasses the fact that the smart TV doesn’t understand anything about VPNs or proxies, since the GL.iNet can handle this.</p>
<p>The following diagram shows the resulting connectivity graph. On the right, I show that the GL.iNet connects to my existing WiFi network, and also exposes a new WiFi network for the smart TV to connect to. In this setup, nothing in my apartment connects to the streaming service directly. Instead, the Linux server at my parents house talks both to the streaming service and to my apartment, essentially turning my parents’ house into a proxy.</p>
<figure class="wp-block-image size-large"><img alt="A connectivity diagram of a network with two boxes. On the right is a box labeled &quot;My apartment&quot;, and on the left is one labeled &quot;Parents' house&quot;. There are arrows showing connections between machines in both locations, including a linux server, a router in both homes, a smart TV, and a GL-iNet" class="wp-image-610" height="703" sizes="(max-width: 1024px) 100vw, 1024px" src="img/global_diagram-1024x703.jpg" width="1024"/></figure>
<p></p>
<p>This might sound pretty straightforward, and I believed that it would be when I started this project. However, it turned out to be pretty frustrating, requiring hours of time debugging and googling before I was able to get everything right. There were a few things that made this difficult. Most importantly, I started with only a rudimentary understanding of how the Linux kernel routes network packets, and this resulted in a lot of initial confusion. Additionally, I hadn’t used OpenWrt before, so I was starting from square one when it came to working with configuration files on the GL.iNet. More generally, I chose to use a lot of tools that I’d never used before, and this created a pretty steep learning curve.</p>
<p>I’ll split this post up into a few parts, describing the different steps I passed through on the path to my final setup. Roughly, I’ll talk about these three things:</p>
<ol>
<li>Setting up a VPN, in this case WireGuard, to connect my GL.iNet to the server at my parents’ house.</li>
<li>The initial configuration I tried on the GL.iNet to tunnel traffic, and the hacky solution that eventually worked.</li>
<li>How I cleaned up the routing table on the GL.iNet to isolate tunneling to a single “guest” WiFi network.</li>
</ol>
<h2 class="wp-block-heading">Setting up WireGuard</h2>
<p>This is the part that I actually got mostly right on the first try. My goal was to create a VPN between the GL.iNet and the server at my parents’ house. I had heard good things about WireGuard, so I started by following <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-wireguard-on-ubuntu-20-04">this lovely DigitalOcean tutorial</a>. After following this tutorial, I ended up with a WireGuard configuration on the server that looked like this:</p>
<figure class="wp-block-image size-large"><img alt="A wireguard configuration on a Linux machine. There are red boxes over private and public keys and remote IP addresses." class="wp-image-617" height="356" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/saturn_wg_2-1024x356.png" width="1024"/></figure>
<p>This configuration creates an interface (in my case, <code>wg0</code>) with a local IP address <code>10.8.0.1</code>. The <code>[Peer</code>] section allows another WireGuard client (which will be the GL.iNet) to connect to this server and register itself with some other IP address <code>10.8.0.x</code> (in my case, <code>10.8.0.2</code>).</p>
<p>As far as I understand it, the <code>iptables</code> commands in <code>PostUp</code> setup NAT’ing, where <code>10.8.0.1</code> will act as a “router” of its own. In particular, this server is connected to my parents’ network over an Ethernet interface <code>enp0s31f6</code>. It has its own IP, something like <code>192.168.1.123</code>, and can access the internet by sending packets over this interface with <code>192.168.1.123</code> as the source IP. What we’d like is for traffic from other clients on the WireGuard interface to be routed through <code>enp0s31f6</code> so that they can access the internet through this same Ethernet connection. The <code>MASQUERADE</code> rule does this. In particular, when <code>wg0</code> receives a packet from some other IP (e.g. <code>10.8.0.2</code>) which is destined for some external IP (e.g. <code>8.8.8.8</code>), some module in the kernel will know to rewrite the source IP in the packet to its own local IP (<code>192.168.1.123</code>) and send it over <code>enp0s31f6</code>. Furthermore, when it receives response packets on <code>enp0s31f6</code> for this same logical connection (presumably identified by port and remote address), it will forward them back to <code>10.8.0.2</code> on <code>wg0</code>.</p>
<p>Unfortunately, the tutorial I was following did not describe how to setup WireGuard on an OpenWrt router. To achieve this, I basically mashed together several examples from internet forums to create the following client configuration on the GL.iNet:</p>
<figure class="wp-block-image size-large"><img alt="An OpenWrt UCI configuration block for a WireGuard client. There are red boxes hiding private and public keys as well as remote IP addresses." class="wp-image-587" height="441" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/interface_wg0-1024x441.png" width="1024"/></figure>
<p>One important point, which took me a while to discover, is that <code>allowed_ips</code> has to include <code>0.0.0.0/0</code>. Without this, I wasn’t able to send packets destined for arbitrary IP addresses over the <code>wg0</code> interface (well, I could send them, but they’d silently get dropped). In retrospect, <code>route_allowed_ips</code> doesn’t really need to be enabled, since the default route it ended up creating didn’t work (which we’ll get to later). Also note that the <code>endpoint_host</code> is set to my parents’ remote IP, and I had to forward port 51821 on their router to my server.</p>
<p>With this configuration in place, I could run the <code>wg</code> command on the GL.iNet and find that the VPN was connected properly. I was also able to use the address <code>10.8.0.1</code> to ping and SSH into my server from the GL.iNet, indicating that things were mostly wired up correctly.</p>
<figure class="wp-block-image size-large"><img alt="The output of the wg WireGuard command on a GL.iNet router. Private information is hidden by red boxes." class="wp-image-589" height="417" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/wg-1024x417.png" width="1024"/></figure>
<p>One hiccup I ran into was that, at first, I hadn’t added a <code>[Peer]</code> section to the WireGuard config on my server. As a result, the client was unable to connect to it, but the output of <code>wg</code> on the GL.iNet still looked basically the same (except that the <code>latest handshake</code> line was missing). As someone who hadn’t used WireGuard before, it was tough for me to tell that anything was wrong. In my opinion, WireGuard should make it more obvious when it hasn’t ever been able to reach a peer, since I wasn’t sure what to look for to see where things were broken.</p>
<h2 class="wp-block-heading">Routing Traffic over WireGuard</h2>
<p>After setting up WireGuard, I SSH’d into the GL.iNet and ran <code>traceroute google.com</code> to see if traffic was being routed through my parents’ home network. Surprisingly, traffic was still being routed directly over my apartments’ wireless network (the router of which was at <code>192.168.1.1</code>), bypassing WireGuard altogether:</p>
<figure class="wp-block-image size-large"><img alt="The output of a traceroute to google.com, with the first hop hitting 192.168.1.1. Some addresses are hidden by red boxes." class="wp-image-618" height="310" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/bad_traceroute-1024x310.png" width="1024"/></figure>
<p>At the time, I had no idea why this would be the case. I understood a bit about routing tables, so I looked at the output of <code>ip route show</code>. I saw a default route over <code>wg0</code> (presumably created by the WireGuard <code>route_allowed_ips</code> flag), and a second one via my apartment’s WiFi (via the <code>apcli0</code> device).</p>
<figure class="wp-block-image size-large"><img alt="The output of the command `ip route show`, with a remote IP address censored by a red box." class="wp-image-592" height="241" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/image-1024x241.png" width="1024"/></figure>
<p>I tried deleting the latter default route, leaving only the route over <code>wg0</code>. To my dismay, I found that it made no difference: the output of <code>traceroute</code> was unchanged! While I later discovered what was actually going on, I’ll tell this story in chronological order by first describing a ridiculous workaround that I found to this problem.</p>
<p>I noticed that I could create specific routes to forward individual destination IP addresses through <code>wg0</code>, and these routes <em>did</em> seem to work. For example, I added a route for my personal website via the command</p>
<p class="has-text-align-center"><code># route add -host 198.74.59.95 dev wg0</code></p>
<p>and then all traffic to <code>198.74.59.95</code> was correctly routed through WireGuard. I suspected that this had to do with the way the routing table prioritizes routes. In particular, more specific routes take higher precedence than general routes. The routes I was creating were about as specific as it gets, since they were scoped to single addresses, so of course they’d be the highest priority.</p>
<p>At this point, I was pretty sure that I could route all traffic over <code>wg0</code> by creating a route for all 2^32 IPv4 addresses. However, I didn’t want to test how the Linux kernel would handle this kind of ridiculousness, so I instead created roughly 256 routes, each forwarding <code>x.0.0.0/8</code> over <code>wg0</code>. I figured out how to do this via OpenWrt’s UCI configuration files, and dumped the output of the following Python script at the end of <code>/etc/config/network</code>:</p>
<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img alt="This is Python code which creates many routes in an OpenWrt UCI configuration file." class="wp-image-907" height="274" loading="lazy" sizes="(max-width: 373px) 100vw, 373px" src="img/routecode.png" width="373"/></figure></div>
<p>After setting up this configuration, I indeed saw <code>traceroute</code> doing the right thing when accessing external IP addresses:</p>
<div class="wp-block-image">
<figure class="aligncenter size-large"><img alt="The output of a traceroute to google.com, where the first hop is 10.8.0.1 and the second is 192.168.1.1. Further hops are censored out by red boxes." class="wp-image-621" height="198" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/good_traceroute-1024x198.png" width="1024"/></figure></div>
<p>Note from this output that the traffic first hops to <code>10.8.0.1</code> and then to <code>192.168.1.1</code>. You might be concerned that traffic is still going over my apartments’ router at <code>192.168.1.1</code>, but worry not. Just to maximize confusion, my parents’ router also has the local IP address <code>192.168.1.1</code>, and that’s the hop that we are seeing in this case.</p>
<p>Now that traffic on the GL.iNet was being routed over the VPN, I figured I’d try setting up an actual WiFi network. When I first configured the network on the GL.iNet, I connected to it from my laptop and found that traffic couldn’t get through to the internet at all. I ended up needing the following firewall configuration (in <code>/etc/config/firewall</code>) on the GL.iNet in order to pass traffic correctly from the “guest” WiFi network to the WireGuard interface:</p>
<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><img alt="An OpenWrt UCI configuration file defining firewall zones for a guest WiFi network and a wireguard device." class="wp-image-624" height="599" loading="lazy" sizes="(max-width: 313px) 100vw, 313px" src="img/zones-535x1024.png" width="313"/></figure></div>
<p>It took an embarrassingly long time to get this config right, and each time I changed it, I had to wait a minute or two for various services on the GL.iNet to restart. Most troubling of all was the <code>mtu_fix</code> flag, which took me about two hours to discover. Before I set that flag, I was already able to access most websites from the new WiFi network, and they were correctly tunneled through my parents’ home network. However, some websites did not load at all, and <code>curl -v</code> typically showed that the connection was stalling during the TLS handshake.</p>
<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><img alt='The output of `curl -v` to google.com with a red arrow pointing to a particular line, saying "Froze here".' class="wp-image-690" height="187" loading="lazy" sizes="(max-width: 727px) 100vw, 727px" src="img/curlv-1024x264.png" width="727"/></figure></div>
<p>I found <a href="https://unix.stackexchange.com/questions/252977/curl-hangs-after-client-hello">this thread</a> after some googling, which suggested an MTU issue. The MTU is essentially the maximum size of a packet that can pass through a network device. For most common networks, this seems to default to 1500, but for the WireGuard interface on my GL.iNet, it was 1420 (as shown by <code>ip addr</code>):</p>
<figure class="wp-block-image size-large"><img alt="An `ip addr` entry describing a wg0 interface. Shows that the MTU of the interface is 1420." class="wp-image-634" height="83" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/wg_mtu-1024x83.png" width="1024"/></figure>
<p>This isn’t a mistake, but rather a side effect of the fact that WireGuard wraps packets with some extra headers, which apparently take up 80 bytes. However, my laptop believed that the WiFi network had an MTU of 1500, as shown by <code>ip addr</code>:</p>
<figure class="wp-block-image size-large"><img alt="The output of an `ip addr` command with an arrow pointing to the MTU of 1500." class="wp-image-628" height="194" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/high_mtu-1024x194.png" width="1024"/></figure>
<p>To test the hypothesis that mismatching MTUs were causing the stalled connections, I manually overrode the MTU of the <code>wlp0s20f3</code> interface on my laptop to a smaller value, using the command </p>
<p class="has-text-align-center"><code># sudo ip link set mtu 1300 wlp0s20f3</code></p>
<p>And presto, suddenly all websites loaded without any problems! Of course, I couldn’t manually override the MTU of network interfaces on my smart TV, so I needed another solution. After reading about <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">path MTU discovery</a>, I noticed a technique called MSS clamping, where a router in the network path modifies the “maximum segment size” field of TCP packets to fill in the minimum MTU of the devices it knows about. I was about to implement this by hand (perhaps with <code>iptables</code> or even eBPF) when I noticed the <code>mtu_fix</code> field in the <a href="https://openwrt.org/docs/guide-user/firewall/firewall_configuration">OpenWrt firewall config documentation</a>:</p>
<blockquote class="wp-block-quote">
<figure class="wp-block-image size-large"><img alt="A screenshot of OpenWrt UCI documentation, with the mtu_fix field highlighted by a red circle." class="wp-image-629" height="521" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/mtu_fix-1024x521.png" width="1024"/></figure>
</blockquote>
<p>I enabled this option, and boom, connections worked even without manually overriding the MTU of my network interface! I still don’t know what will happen when using non-TCP protocols like QUIC, and I do slightly worry about that. In the future, I’d like to figure out a way to make my VPN support larger packets <em>without</em> constraining the MTU, even if it does mean creating more packet fragmentation.</p>
<h2 class="wp-block-heading">Cleaning up the Routing Table</h2>
<p>While my current solution did technically solve the problem I had set out to solve, it had two downsides that I wanted to address:</p>
<ol>
<li>It was messy. I now had over 256 routing table entries, and it felt like this shouldn’t be necessary. Ideally, I should be able to use a single routing table entry to forward all traffic over <code>wg0</code>. It was currently a mystery why this did not work as expected.</li>
<li>The <code>wg0</code> routes were applied globally. Ideally, these routes would only be applied to traffic coming from the special WiFi network itself. This might be a problem if, for example, I wanted to expose <em>two</em> WiFi networks from the GL.iNet: one which acts as a normal repeater, and another one that tunnels traffic through my parents’ house. With my current setup, this would be impossible.</li>
</ol>
<p>To solve the first problem, I had to learn more about how Linux routes IP traffic. Up until now, I only knew about the “main” routing table, which can be shown and manipulated with the deprecated <code>route</code> command, or with the <code>ip route</code> command without a <code>table</code> argument. A routing table itself only uses the destination IP address of a packet to determine which device (and gateway) to send that packet to. This isn’t very flexible, since it doesn’t allow us to consider the source address or other attributes of the packet.</p>
<p>To create more complex routing rules, we can use the <code>ip rule</code> command to configure Linux’s <a href="http://linux-ip.net/html/routing-rpdb.html">routing policy database</a> (RPDB). This lets us use various information about each packet to determine which routing table(s) to look at. To see all of the rules in the RPDB, we can use the <code>ip rule</code> command. Here was the output on the GL.iNet:</p>
<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img alt="The output of an `ip rule` command, showing several rules including ones pointing to table 2." class="wp-image-659" height="214" loading="lazy" sizes="(max-width: 693px) 100vw, 693px" src="img/actualrules-2.png" width="693"/></figure></div>
<p>By default, there will only be three tables (<code>local</code>, <code>main</code>, and <code>default</code>) and one rule for each of them. In the output above, we see more rules, including this one:</p>
<p class="has-text-align-center"><code>from all fwmark 0x200/0x3f00 lookup 2</code></p>
<p>This rule points to table 2 (a different table than any of the built-in ones), and matches all traffic where <code>fwmark &amp; 0x3f00 == 0x200</code>. Apparently, <code>fwmark</code> (the “firewall mark”) is an additional number associated with each packet that can be modified by firewall rules. I can’t claim to understand what sets this particular firewall mark on packets coming through this particular system, and I’d definitely like to understand more about this. Regardless, let’s take a look at table 2, since that’s where this rule points to:</p>
<figure class="wp-block-image size-large"><img alt="The output of `ip route show table 2`, revealing a default route pointing to 192.168.1.1." class="wp-image-892" height="215" loading="lazy" sizes="(max-width: 1024px) 100vw, 1024px" src="img/table2-1024x215.png" width="1024"/></figure>
<p>Aha! This routing table contains its own default route over <code>apcli0</code> through <code>192.168.1.1</code> (my apartment’s router). This is a <em>different</em> default route than the one we saw earlier, which had been in the <code>main</code> table. Out of curiosity, I tried deleting all of my earlier custom routing rules, and additionally deleted the table 2 rule with:</p>
<p class="has-text-align-center"><code># ip rule del fwmark 0x200/0x3f00 lookup 2</code></p>
<p>After deleting this rule, the default <code>wg0</code> route from the <code>main</code> routing table took effect, automatically routing all traffic over the VPN! So this at least solved one mystery: I had only been looking at the <code>main</code> routing table, but there was a higher-priority rule that was directing traffic to a different default route than the one I was looking at. Granted, I still don’t know what created table 2 or the corresponding rules pointing to it, and some preliminary grep’ing of <code>/etc</code> didn’t yield anything particularly informative. I’d be curious to know if anybody else knows the answer.</p>
<p>Moving onto the second problem, I leveraged my newfound knowledge of policy routing to narrow the scope of the VPN route. In particular, I only wanted to route traffic over the VPN if it was coming from machines on a guest WiFi network. Since I configured my GL.iNet’s guest WiFi network to assign IP addresses in the range <code>192.168.9.128</code> through <code>192.168.9.254</code>, all I needed to do was define a routing rule to route traffic from this range over the <code>wg0</code> interface. I started by testing this idea with the <code>ip</code> command, and then created a UCI config for it in <code>/etc/config/network</code>:</p>
<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img alt="An OpenWrt UCI config file containing both a `config rule` and a `config route`. These operate on table 101, and make a select range of source IP addresses get forwarded to the wg0 interface." class="wp-image-652" height="256" loading="lazy" sizes="(max-width: 509px) 100vw, 509px" src="img/pbr_rules.png" width="509"/></figure></div>
<p>This configuration adds a route to table 101 (an arbitrary number I selected) with a single entry: a default route over <code>wg0</code>. The <code>config rule</code> section creates a rule to point all traffic coming from IPs on the guest WiFi network to this new table. After doing so, we can see the effects with the <code>ip</code> command:</p>
<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img alt="The output of `ip rule` and `ip route` showing the result of a new routing rule which is scoped to a select range of IP addresses and routes this traffic to the wg0 interface." class="wp-image-660" height="277" loading="lazy" sizes="(max-width: 622px) 100vw, 622px" src="img/newrules.png" width="622"/></figure></div>
<p>The end result is that traffic from the guest WiFi network is routed over <code>wg0</code>, but traffic from the GL.iNet itself, or from other WiFi networks exposed by the GL.iNet, is not. I actually tested this by exposing a second WiFi network from the GL.iNet and verifying that its traffic was <em>not</em> routed through the VPN. This was more of a victory lap than anything else, to verify that I actually understood what was going on.</p>
<h2 class="wp-block-heading">Conclusion</h2>
<p>After going through this saga, I decided that it was time to set this project down for a while. I had a working setup, and ended up learning a lot more than I intended.</p>
<p>However, I was left with a few unanswered questions at the end of the process:</p>
<ul>
<li>Is there a better alternative to MSS clamping? And what happens for other protocols like QUIC? And perhaps more importantly, why isn’t standard MTU path discovery working in the first place?</li>
<li>What created the routing table 2 in the first place, and those two rules pointing to it? And what is setting the 0x200 fwmark that triggers the routing rule in the first place?</li>
<li>Why is the network so slow? At the moment, it’s only able to achieve 5-10 Mb/s, which is much slower than my personal network or my parents’ network. I think this may be a limitation of the GL.iNet itself, since the speed isn’t much better even without tunneling through the VPN.</li>
</ul>
<p>Even though I reached my goal, there’s more work that I could have done. At the moment, I don’t do anything to tunnel DNS traffic, so my apartment’s ISP still happens to determine the DNS server that my TV uses. I don’t think streaming services will notice this, but it could be worth fixing even if just for privacy reasons while traveling with my GL.iNet in the future.</p>
<p>I spent about $30 on the GL.iNet, which is enough to purchase a few months of any reasonably-priced streaming service. While it was probably not worth the effort from a monetary standpoint, I still think it was worth it 100 times over when factoring in the learning I got to do along the way.</p>
<p>I’ll leave you with the observation that this project didn’t require writing any real code! It’s unusual for me to spend so much time working on something that really boils down to writing the right config files. Perhaps that’s a testament to how powerful the Linux kernel (and other existing software) is when it comes to networking. Or, perhaps, it’s a sign that what I did wasn’t really that interesting or impressive at all.</p>
</div><!-- .entry-content -->
<!-- .entry-footer -->
</article></body></html>